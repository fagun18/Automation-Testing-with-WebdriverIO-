import { types as nodeUtilTypes } from 'node:util';
import { diffWordsWithSpace } from 'diff';
import objectInspect from 'object-inspect';
import RunnableStats from './runnable.js';
import { pad, color, colorLines } from '../utils.js';
const maxStringLength = 2048;
/**
 * TestStats class
 * captures data on a test.
 */
export default class TestStats extends RunnableStats {
    uid;
    cid;
    title;
    currentTest;
    fullTitle;
    output;
    argument;
    retries;
    parent;
    /**
     * initial test state is pending
     * the state can change to the following: passed, skipped, failed
     */
    state;
    pendingReason;
    errors;
    error;
    body;
    constructor(test) {
        super('test');
        this.uid = RunnableStats.getIdentifier(test);
        this.cid = test.cid;
        this.title = test.title;
        this.fullTitle = test.fullTitle;
        this.output = [];
        this.argument = test.argument;
        this.retries = test.retries;
        this.parent = test.parent;
        // Mocha only
        this.body = test.body;
        /**
         * initial test state is pending
         * the state can change to the following: passed, skipped, failed
         */
        this.state = 'pending';
    }
    pass() {
        this.complete();
        this.state = 'passed';
    }
    skip(reason) {
        this.pendingReason = reason;
        this.state = 'skipped';
    }
    fail(errors) {
        this.complete();
        this.state = 'failed';
        /**
         * Iterates through all errors to check if they're a type of 'AssertionError',
         * and formats it if so. Otherwise, just leaves error as is
         */
        const formattedErrors = errors?.map((err) => (
        /**
         * only format if error object has either an "expected" or "actual" property set
         */
        ((err.expected || err.actual) && !nodeUtilTypes.isProxy(err.actual)) &&
            /**
             * and if they aren't already formated, e.g. in Jasmine
             */
            (err.message && !err.message.includes('Expected: ') && !err.message.includes('Received: '))
            ? this._stringifyDiffObjs(err)
            : err));
        this.errors = formattedErrors;
        if (formattedErrors && formattedErrors.length) {
            this.error = formattedErrors[0];
        }
    }
    _stringifyDiffObjs(err) {
        const inspectOpts = { maxStringLength };
        const expected = objectInspect(err.expected, inspectOpts);
        const actual = objectInspect(err.actual, inspectOpts);
        let msg = diffWordsWithSpace(actual, expected)
            .map((str) => (str.added
            ? colorLines('diff added inline', str.value)
            : str.removed
                ? colorLines('diff removed inline', str.value)
                : str.value))
            .join('');
        // linenos
        const lines = msg.split('\n');
        if (lines.length > 4) {
            const width = String(lines.length).length;
            msg = lines
                .map(function (str, i) {
                return pad(String(++i), width) + ' |' + ' ' + str;
            })
                .join('\n');
        }
        // legend
        msg = `\n${color('diff removed inline', 'actual')} ${color('diff added inline', 'expected')}\n\n${msg}\n`;
        // indent
        msg = msg.replace(/^/gm, '      ');
        const newError = new Error(err.message + msg);
        newError.stack = err.stack;
        return newError;
    }
}
