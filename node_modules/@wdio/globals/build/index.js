/// <reference path="../types.d.ts" />
/**
 * As this file gets imported/used as ESM and CJS artifact we have to make sure
 * that we can share the globals map across both files. For example if someone
 * runs a CJS project, we run this file as ESM (/build/index.js) first, but when
 * imported in the test, the same file will be used as CJS version (/cjs/index.js)
 * and can use the Map initiated by the testrunner by making it accessible globally.
 */
const globals = globalThis._wdioGlobals = globalThis._wdioGlobals || new Map();
const GLOBALS_ERROR_MESSAGE = 'No browser instance registered. Don\'t import @wdio/globals outside of the WDIO testrunner context. Or you have two two different "@wdio/globals" packages installed.';
function proxyHandler(key) {
    return {
        get: (self, prop) => {
            if (!globals.has(key)) {
                throw new Error(GLOBALS_ERROR_MESSAGE);
            }
            const receiver = globals.get(key);
            const field = receiver[prop];
            return typeof field === 'function'
                ? field.bind(receiver)
                : field;
        }
    };
}
export const browser = new Proxy(class Browser {
}, proxyHandler('browser'));
export const driver = new Proxy(class Browser {
}, proxyHandler('driver'));
export const multiremotebrowser = new Proxy(class Browser {
}, proxyHandler('multiremotebrowser'));
export const $ = (...args) => {
    if (!globals.has('$')) {
        throw new Error(GLOBALS_ERROR_MESSAGE);
    }
    return globals.get('$')(...args);
};
export const $$ = (...args) => {
    if (!globals.has('$$')) {
        throw new Error(GLOBALS_ERROR_MESSAGE);
    }
    return globals.get('$$')(...args);
};
export const expect = ((...args) => {
    if (!globals.has('expect')) {
        throw new Error(GLOBALS_ERROR_MESSAGE);
    }
    return globals.get('expect')(...args);
});
const ASYNC_MATCHERS = [
    'any',
    'anything',
    'arrayContaining',
    'objectContaining',
    'stringContaining',
    'stringMatching',
];
for (const matcher of ASYNC_MATCHERS) {
    expect[matcher] = (...args) => {
        if (!globals.has('expect')) {
            throw new Error(GLOBALS_ERROR_MESSAGE);
        }
        return globals.get('expect')[matcher](...args);
    };
}
expect.not = ASYNC_MATCHERS.reduce((acc, matcher) => {
    acc[matcher] = (...args) => {
        if (!globals.has('expect')) {
            throw new Error(GLOBALS_ERROR_MESSAGE);
        }
        return globals.get('expect').not[matcher](...args);
    };
    return acc;
}, {});
expect.extend = (...args) => {
    if (!globals.has('expect')) {
        throw new Error(GLOBALS_ERROR_MESSAGE);
    }
    const expect = globals.get('expect');
    return expect.extend(...args);
};
/**
 * allows to set global property to be imported and used later on
 * @param key global key
 * @param value actual value to be returned
 * @private
 */
export function _setGlobal(key, value, setGlobal = true) {
    globals.set(key, value);
    if (setGlobal) {
        // @ts-expect-error
        globalThis[key] = value;
    }
}
