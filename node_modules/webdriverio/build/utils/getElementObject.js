import { webdriverMonad, wrapCommand } from '@wdio/utils';
import clone from 'lodash.clonedeep';
import { ELEMENT_KEY } from 'webdriver';
import { getBrowserObject } from '@wdio/utils';
import { getPrototype as getWDIOPrototype, getElementFromResponse } from './index.js';
import { elementErrorHandler } from '../middlewares.js';
import * as browserCommands from '../commands/browser.js';
class WebDriverError extends Error {
    constructor(obj) {
        const { name, stack } = obj;
        const { error, stacktrace } = obj;
        super(error || name || '');
        Object.assign(this, {
            message: obj.message,
            stack: stacktrace || stack,
        });
    }
}
/**
 * transforms a findElement response into a WDIO element
 * @param  {string} selector  selector that was used to query the element
 * @param  {Object} res       findElement response
 * @return {Object}           WDIO element object
 */
export const getElement = function findElement(selector, res, props = { isReactElement: false, isShadowElement: false }) {
    const browser = getBrowserObject(this);
    const browserCommandKeys = Object.keys(browserCommands);
    const propertiesObject = {
        /**
         * filter out browser commands from object
         */
        ...(Object.entries(clone(browser.__propertiesObject__)).reduce((commands, [name, descriptor]) => {
            if (!browserCommandKeys.includes(name)) {
                commands[name] = descriptor;
            }
            return commands;
        }, {})),
        ...getWDIOPrototype('element'),
        scope: { value: 'element' }
    };
    const element = webdriverMonad(this.options, (client) => {
        const elementId = getElementFromResponse(res);
        if (elementId) {
            /**
             * set elementId for easy access
             */
            client.elementId = elementId;
            /**
             * set element id with proper key so element can be passed into execute commands
             */
            if (this.isW3C) {
                client[ELEMENT_KEY] = elementId;
            }
            else {
                client.ELEMENT = elementId;
            }
        }
        else {
            client.error = res;
        }
        client.selector = selector || '';
        client.parent = this;
        client.emit = this.emit.bind(this);
        client.isReactElement = props.isReactElement;
        client.isShadowElement = props.isShadowElement;
        return client;
    }, propertiesObject);
    const elementInstance = element(this.sessionId, elementErrorHandler(wrapCommand));
    const origAddCommand = elementInstance.addCommand.bind(elementInstance);
    elementInstance.addCommand = (name, fn) => {
        browser.__propertiesObject__[name] = { value: fn };
        origAddCommand(name, fn);
    };
    return elementInstance;
};
/**
 * transforms a findElements response into an array of WDIO elements
 * @param  {string} selector  selector that was used to query the element
 * @param  {Object} res       findElements response
 * @return {Array}            array of WDIO elements
 */
export const getElements = function getElements(selector, elemResponse, props = { isReactElement: false, isShadowElement: false }) {
    const browser = getBrowserObject(this);
    const browserCommandKeys = Object.keys(browserCommands);
    const propertiesObject = {
        /**
         * filter out browser commands from object
         */
        ...(Object.entries(clone(browser.__propertiesObject__)).reduce((commands, [name, descriptor]) => {
            if (!browserCommandKeys.includes(name)) {
                commands[name] = descriptor;
            }
            return commands;
        }, {})),
        ...getWDIOPrototype('element')
    };
    const elements = [elemResponse].flat(1).map((res, i) => {
        /**
         * if we already deal with an element, just return it
         */
        if (res.selector && '$$' in res) {
            return res;
        }
        propertiesObject.scope = { value: 'element' };
        const element = webdriverMonad(this.options, (client) => {
            const elementId = getElementFromResponse(res);
            if (elementId) {
                /**
                 * set elementId for easy access
                 */
                client.elementId = elementId;
                /**
                 * set element id with proper key so element can be passed into execute commands
                 */
                const elementKey = this.isW3C ? ELEMENT_KEY : 'ELEMENT';
                client[elementKey] = elementId;
            }
            else {
                res = res;
                client.error = res instanceof Error ? res : new WebDriverError(res);
            }
            client.selector = Array.isArray(selector)
                ? selector[i].selector
                : selector;
            client.parent = this;
            client.index = i;
            client.emit = this.emit.bind(this);
            client.isReactElement = props.isReactElement;
            client.isShadowElement = props.isShadowElement;
            return client;
        }, propertiesObject);
        const elementInstance = element(this.sessionId, elementErrorHandler(wrapCommand));
        const origAddCommand = elementInstance.addCommand.bind(elementInstance);
        elementInstance.addCommand = (name, fn) => {
            browser.__propertiesObject__[name] = { value: fn };
            origAddCommand(name, fn);
        };
        return elementInstance;
    });
    return elements;
};
